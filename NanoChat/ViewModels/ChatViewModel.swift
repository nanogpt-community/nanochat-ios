import Foundation
import SwiftUI

@MainActor
final class ChatViewModel: ObservableObject {
    @Published var conversations: [ConversationResponse] = []
    @Published var messages: [MessageResponse] = []
    @Published var currentConversation: ConversationResponse?
    @Published var isLoading = false
    @Published var isGenerating = false
    @Published var errorMessage: String?
    @Published var webSearchEnabled = false
    @Published var webSearchMode: WebSearchMode = .off
    @Published var webSearchProvider: WebSearchProvider = .linkup

    private let api = NanoChatAPI.shared

    func loadConversations() async {
        print("ChatViewModel.loadConversations() called")
        isLoading = true
        defer { isLoading = false }

        do {
            print("Fetching conversations from API...")
            let loadedConversations = try await api.getConversations()
            print("Successfully loaded \(loadedConversations.count) conversations")
            conversations = loadedConversations
        } catch {
            print("Error loading conversations: \(error)")
            errorMessage = error.localizedDescription
        }
    }

    func loadMessages(conversationId: String) async {
        isLoading = true
        defer { isLoading = false }

        print("Loading messages for conversation: \(conversationId)")
        do {
            let loadedMessages = try await api.getMessages(conversationId: conversationId)
            print("Loaded \(loadedMessages.count) messages")
            messages = loadedMessages
            if let conversation = conversations.first(where: { $0.id == conversationId }) {
                currentConversation = conversation
            }
        } catch {
            print("Error loading messages: \(error)")
            errorMessage = error.localizedDescription
        }
    }

    func createConversation(title: String? = nil, projectId: String? = nil) async {
        isLoading = true
        defer { isLoading = false }

        do {
            // If title is provided, use regular create
            // Otherwise, createWithMessage will be used when sending first message
            let newConversation: ConversationResponse
            if let title = title {
                newConversation = try await api.createConversation(title: title, projectId: projectId)
            } else {
                // Create a temporary conversation with default title
                // The real title will be generated by the backend
                newConversation = try await api.createConversation(title: "New Chat", projectId: projectId)
            }

            conversations.insert(newConversation, at: 0)
            currentConversation = newConversation
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func sendMessage(
        message: String,
        modelId: String,
        conversationId: String? = nil,
        assistantId: String? = nil,
        webSearchEnabled: Bool = false,
        webSearchMode: String? = nil,
        webSearchProvider: String? = nil,
        images: [ImageAttachment]? = nil,
        documents: [DocumentAttachment]? = nil
    ) async {
        guard !message.isEmpty || images?.isEmpty == false || documents?.isEmpty == false else { return }

        isGenerating = true

        do {
            // Send message generation request
            let response = try await api.generateMessage(
                message: message,
                modelId: modelId,
                conversationId: conversationId ?? currentConversation?.id,
                assistantId: assistantId,
                webSearchEnabled: webSearchEnabled,
                webSearchMode: webSearchMode,
                webSearchProvider: webSearchProvider,
                images: images,
                documents: documents
            )

            print("Generate message response: \(response)")

            // Poll for message updates until generation is complete
            let targetConversationId = conversationId ?? currentConversation?.id ?? response.conversationId

            // Poll for updates (check every 1 second for up to 120 seconds)
            for i in 0..<120 {
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second

                // Reload conversations every 3 seconds to check generating status
                if i % 3 == 0 {
                    await loadConversations()
                }

                // Load messages to get updated content
                await loadMessages(conversationId: targetConversationId)

                // Check if this conversation is still in our list and if it's generating
                let conversation = conversations.first { $0.id == targetConversationId }
                let isStillGenerating = conversation?.generating ?? false

                // Check if the last assistant message has content AND generation is complete
                if let lastMessage = messages.last,
                   lastMessage.role == "assistant",
                   !lastMessage.content.isEmpty,
                   !isStillGenerating {
                    print("Assistant response completed, stopping poll")
                    break
                }

                // If we have content but still generating, keep polling
                if let lastMessage = messages.last,
                   lastMessage.role == "assistant",
                   !lastMessage.content.isEmpty {
                    print("Still generating... (current content length: \(lastMessage.content.count))")
                }
            }

            isGenerating = false
        } catch {
            print("Error sending message: \(error)")
            errorMessage = error.localizedDescription
            isGenerating = false
        }
    }

    func deleteConversation(id: String) async {
        do {
            try await api.deleteConversation(id: id)
            conversations.removeAll { $0.id == id }
            if currentConversation?.id == id {
                currentConversation = nil
                messages = []
            }
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
